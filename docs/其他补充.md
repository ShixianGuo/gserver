# epoll相关
epoll事件驱动机制，在单独的进程或者单独的线程里运行，收集/处理事件；没有进程/线程之间切换的消耗，高效
## 原理简介
### 数据结构
![](https://gitee.com/shixianguo/blogimage/raw/master/img/20200331115859.png)

### 锁机制 
Epoll 从以下几个方面是需要加锁保护的。 List 的操作，rbtree 的操作，epoll_wait 的等待  
```
List:       使用最小粒度的锁 spinlock
Rbtree:     互斥锁
epoll_wait: 采用 pthread_cond_wait
```

### epoll_create
```
创建了一个eventpoll结构对象，被系统保存起来；
rbr成员被初始化成指向一颗红黑树的根【有了一个红黑树】
rdlist成员被初始化成指向一个双向链表的根【有了双向链表】
```
### epoll_ctl
```
int epoll_ctl(int efpd,int op,int sockid,struct epoll_event *event);
//EPOLL_CTL_ADD：等价于往红黑树中增加节点
//EPOLL_CTL_DEL：等价于从红黑树中删除节点
//EPOLL_CTL_MOD：等价于修改已有的红黑树的节点
```
### epoll_wait: 当事件发生，我们如何拿到操作系统的通知
```
int epoll_wait(int epfd,struct epoll_event *events,int maxevents,int timeout);
//说白了就是遍历这个双向链表，把这个双向链表里边的节点数据拷贝出去，拷贝完毕的就从双向链表里移除；
//因为双向链表里记录的是所有有数据/有事件的socket【TCP连接】；
```
### 回调函数何时执行?
一般有四种情况，会使操作系统把节点插入到双向链表中；
```
a)客户端完成三路握手；服务器要accept();
b)当客户端关闭连接，服务器也要调用close()关闭；
c)客户端发送数据来的；服务器要调用read(),recv()函数来收数据；
d)当可以发送数据时；服务武器可以调用send(),write()；
```
###  LT与ET
```
比如：event = EPOLLIN | EPOLLLT，将 event 设置为 EPOLLIN 与水平触发。只要 event 为 EPOLLIN 时就能不断调用 epoll 回调函数  
比如: event = EPOLLIN | EPOLLET，event 如果从 EPOLLOUT 变化为 EPOLLIN 的时候，就会触 发。在此情形下，变化只发生一次，故只调用一次 epoll 回调函数
```
```
ET模式事件只触发一次呢？[事件被扔到双向链表中一次，被epoll_wait取出后就干掉]
LT模式事件会触发多次呢？[事件如果没有处理完，那么事件会被多次往双向链表中扔]
```

# 心跳包相关
## 心跳包基本概念
### 什么叫心跳包以及如何使用
心跳包其实就是 一个普通的数据包；  
一般每个几十秒，最长一般也就是1分钟【10秒-60秒之间】，有客户端主动发送给服务器；服务器收到之后，一般会给客户端返回一个心跳包；

### 为什么引入心跳包?
* 常规客户端关闭，服务器端能感知到
* 有一种特殊情况，连接断开c/s都感知不到: 拔掉网线导致服务器感知不到客户端断开

为了应对拔网线，导致不知道对方是否断开了tcp连接这种事，这就是我们引入心跳包机制的原因；  

超时没有发送来心跳包，那么就会将对端的socket连接close掉，回收资源；这就是心跳包的作用；  

### 设计思路
* 接收心跳包与返回结果：没有包体的收发包
* 处理不发送心跳包的客户端：定时器队列


# 连接池相关
## 连接池连接回收问题

问题：如果客户端【张三】断线，服务器端立即回收连接，这个连接很可能被紧随其后连入的新客户端【李四】所使用，那么这里就很可能产生麻烦；

```
a)张三 funca(); ---执行10秒，服务器从线程池中找一个线程来执行张三的任务；
b)执行到第5秒的时候，张三断线；
c)张三断线这个事情会被服务器立即感知到，服务器随后调用ngx_close_connection把原来属于张三这个连接池中的连接给回收了；
d)第7秒的时候，李四连上来了，系统会把刚才张三用过的连接池中的连接分配给李四【现在这个连接归李四使用】；
e)10秒钟到了，这个线程很可能会继续操纵 连接【修改读数据】；很可能导致服务器整个崩溃；这种可能性是非常有的；
```

所以 一个连接，如果我们程序判断这个连接不用了；那么不应该把这个连接立即放到空闲队列里，而是 应该放到一个地方   

因此 我们可以等待一段时间【比如60】，60秒之后，我再真正的回收这个连接到 连接池/空闲队列 中去，这种连接才可以真正的分配给其他用户使用；  

为什么要等待60秒？就是需要确保即便用户张三真断线了，那么我执行的该用户的业务逻辑也一定能在这个等待时间内全部完成；

```
inRecyConnectQueue(延迟回收)
gsx_close_connection(立即回收)
```

### inRecyConnectQueue
```
将要回收的连接放到一个队列中来，后续有专门的线程会处理这个队列中的连接的回收
```

### ServerRecyConnectionThread //处理连接回收的线程
```
1 遍历延迟回收队列： for(; pos != posend; ++pos)
1-1 if((入延迟回收队列里的时间 + 等待回收连接时间) > currtime) continue; //没到释放的时间
1-2 流程走下来，表示可以释放
1-3 归还参数pConn所代表的连接到到连接池中：>ngx_free_connection(p_Conn)
```